
---

>例题中  
>用集合论来定义数据结构  
>`Group = (P, R)`   
>P为元素集合  
>R为关系集合  
>P = {T, $G_1$ , ... , $G_n$ , $S_{11}$ , ... , $S_{nm}$ }  
>T代表教师  
>G代表研究生  
>$S_{ij}$代表本科生，i表示由第i位研究生指导  
>$R = \lbrace R_1, R_2 \rbrace $   
>R是一个集合，里面是两种不同关系  
>$R_1 = \lbrace <T, G_i> | 1<=i<=n,1<=n<=3 \rbrace $  
>$<T, G_i>$ 表示一个有序对。  
>顺序很重要， $<A, B>$  表示A和B有一个从A指向B的关系  
>所以 $<T, G_i>$ 明确表示“T指导 $G_i$ ”  
>$R_2 = \lbrace <G_i, S_{ij}> | 1<=i<=n, 1<=j<=m, 1<=n<=3, 1<=m<=2 \rbrace $  
>同理， $<G_i, S_{ij}>$ 表示“研究生 $G_i$ 指导本科生 $S_ij$”  

---
  
>字长是指计算机的CPU一次能够处理的数据的宽度（或大小）  
>32位，字长就是32位（4个字节）  
>64为，字长就是64位（8个字节）

---

**线性结构**  
1.只有一个被称为“第一个”的元素  
2.“最后一个”元素同理  
3.除了第一个，每个元素都有一个前驱  
4.后继同理  

---

```c
#pragma once
#include <stdbool.h>
#include <stddef.h>

typedef int ElemType;
typedef bool (*Compare)(ElemType a, ElemType b);
typedef void (*Visit)(ElemType e);

typedef struct {
    ElemType *data;
    int length;
    int capacity;
} List;

bool InitList(List *L, int initCap);
void DestroyList(List *L);
void ClearList(List *L);
bool ListEmpty(const List *L);
int ListLength(const List *L);
bool GetElem(const List *L, int i, ElemType *e);
int LocateElem(const List *L, ElemType e, Compare comp);
bool PriorElem(const List *L, ElemType cur_e, ElemType *pre_e);
bool NextElem(const List *L, ElemType cur_e, ElemType *next_e);
bool ListInsert(List *L, int i, ElemType e);
bool ListDelete(List *L, int i, ElemType *e);
void ListTraverse(const List *L, Visit visit);
```

1. `#pragma once` :的作用是确保这个头文件在一次编译中只被包含一次
2. `#include <stdbool.h>` :引入`bool`,`true`,`false`
3. `#include <stddef.h>` :引入`size_t`,`NULL`
4. `typedef int ElemType` :This defines `ElemType` as an alias for the `int` type.  
